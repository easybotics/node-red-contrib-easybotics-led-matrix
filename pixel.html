<script type="text/javascript">

	function pixelReDraw (points, pixelSelector, drawLines = true, updateFields = true)
	{
		var canvas  = document.getElementById(pixelSelector);
		var context = canvas.getContext("2d");

		context.beginPath();
		for(i = 0; i < points.x.length; i++)
		{
			context.rect(points.x[i] * 4+1, points.y[i] * 4+1, 3, 3);
			context.fillStyle = "#555";
			context.fill();
		}
		context.closePath();

		if(drawLines)
		{
			context.beginPath();
			context.moveTo(points.x[0] * 4 + 2.5, points.y[0] * 4 + 2.5);
			for(i = 1; i < points.x.length; i++)
			{
				context.lineTo(points.x[i] * 4 + 2.5, points.y[i] * 4 + 2.5);
			}

			context.lineTo(points.x[0] * 4 + 2.5, points.y[0] * 4 + 2.5);

			context.lineWidth = 1;
			context.strokeStyle = "#555";
			context.stroke();

			context.closePath();
		}

	}

	function getMousePos(canvas, evt)
	{
		var rect = canvas.getBoundingClientRect();

		return {	//mouse x pos - how far rect is from edge of page / num of screen pixels per "pixel" in the canvas (finds what canvas pixel the mouse is in)
					x: Math.floor((evt.clientX - rect.left) / 4),
					y: Math.floor((evt.clientY - rect.top) / 4)
			   };
	}

	function drawGrid (canvas, context)
	{
		context.beginPath();

		for (var x = 0.5; x < canvas.width; x += 4)
		{
			context.moveTo(x, 0);
			context.lineTo(x, 256);
		}

		for (var y = 0.5; y < canvas.height; y += 4)
		{
			context.moveTo(0, y);
			context.lineTo(512, y);
		}

		context.lineWidth = 1;
		context.strokeStyle = "#ddd";
		context.closePath();
		context.stroke();
	}

	function ptNear(points, coord, range = 2) //coord: coordinate of point to check as object with format {x: x-coord, y: y-coord}, range: how far from the clicked pt to search for points
	{
		for(i = coord.x-range; i <= coord.x+range; i++) {
			for(j = coord.y-range; j <= coord.y+range; j++) {
				if(points.x.includes(i) && points.y[points.x.indexOf(i)] == j) {
					return points.x.indexOf(i); //returns index of x and y coordinates
				}
			}
		}
		return false; //if no pts within range of clicked pt
	}

	/*
	 * function to draw a grid on the canvas for the pixel selector and give the coordinates of the selected pixel
	 * numPoints: number of points in the polygon, pixelSelector: canvas to use, drawLines: draw the resulting shape or not,
	 * updateFields: whether or not to change input text fields, outputCanvas: canvas to send the scaled down version of the pixelSelector
	 * canvas to (used for exporting as image, input as string id of canvas),
	 * colorSelector: id of the color selector to use for output to the outputCanvas
	 */
	function pixelSelector (numPoints, pixelSelector, drawLines = true, updateFields = true, outputCanvas = false, colorSelector = false)
	{

		var canvas = document.getElementById(pixelSelector);
		var context = canvas.getContext("2d");

		var currentPoint = {};
		var points = { x: [], y: [] };

		if(outputCanvas != false) {
			var outCanvas = document.getElementById(outputCanvas);
			var outContext = outCanvas.getContext("2d");
			outContext.translate(0.5, 0.5);
		}

		if(colorSelector == false) { //if no color selector specified
			var color = "#fff";
		}

		if(updateFields) { //get the numbers in the input fields
			for(i = 0; i < numPoints; i++) {
				points.x.push(parseInt(document.getElementById("node-input-x"+i).value));
				points.y.push(parseInt(document.getElementById("node-input-y"+i).value));
			}
		}

		drawGrid(canvas, context);
		pixelReDraw(points, pixelSelector, drawLines, updateFields);

		canvas.addEventListener('mousedown', function(evt)
		{
			currentPoint.down = getMousePos(canvas, evt);
		});

		canvas.addEventListener('mouseup', function(evt)
		{
			currentPoint.up = getMousePos(canvas, evt);

			if(currentPoint.down.x == currentPoint.up.x && currentPoint.down.y == currentPoint.up.y) { //if mouse not dragged
				points.x.push(currentPoint.up.x);
				points.y.push(currentPoint.up.y);
			} else if (ptNear(points, currentPoint.down) !== false) { //mouse dragged and starting on/near a point
				//update the selected point
				ptIndex = ptNear(points, currentPoint.down)
				points.x[ptIndex] = currentPoint.up.x;
				points.y[ptIndex] = currentPoint.up.y;
			} else { //if mouse dragged, not starting on a point
				points.x.push(currentPoint.up.x);
				points.y.push(currentPoint.up.y);
			}

			context.clearRect(0, 0, canvas.width, canvas.height);
			drawGrid(canvas, context);

			if(points.x.length == numPoints+1)
			{ //if the number of points is one too many
				points.x.splice(0, 1); //removes the first value from x & y arrays
				points.y.splice(0, 1);
			}

			for(i = 0; i < points.x.length; i++)
			{
				if(updateFields)
				{
					document.getElementById("node-input-x"+i).value = points.x[i]; //set input fields to the coordinates of each pixel
					document.getElementById("node-input-y"+i).value = points.y[i];
				}
			}

			if(outputCanvas != false)
			{
				if(numPoints == points.x.length) { //if all pts selected

					if(colorSelector != false) { //get color to draw shape with
						var color = document.getElementById(colorSelector).value;
					}

					outContext.clearRect(0, 0, outCanvas.width, outCanvas.height); //clear anything already on the canvas

					outContext.beginPath();
					outContext.moveTo(points.x[0], points.y[0]);

					for(i = 0; i < points.x.length; i++) {
						outContext.lineTo(points.x[i], points.y[i]);
					}
					outContext.lineTo(points.x[0], points.y[0]);

					outContext.lineWidth = 1;
					outContext.strokeStyle = color;
					outContext.stroke();
					outContext.closePath();
				}
			}

			pixelReDraw(points, pixelSelector, drawLines, updateFields);
		});
	}

</script>

<script type="text/javascript">
	RED.nodes.registerType('led-matrix', {
		category: 'config',
		defaults: {
			height: {value:64, required:true},
			width:  {value:64, required:true},
			chained: {value:2, required:true},
			parallel: {value:1, required:true},
			brightness: {value:100, required:true},
			refreshDelay: {value:500, required:true},
			mapping: {value:"adafruit-hat-pwm", required:true},
			autoRefresh: {value:true},
		},

		oneditprepare: function ()
		{


			$("#node-config-refreshCheck").change( function()
				{
					const val = $("#node-config-refreshCheck").val();
					this.autoRefresh = (val === "true");
				});

			if(this.autoRefresh)
			{
				$("#node-config-refreshCheck").val("true");
			}
			else
			{

				$("#node-config-refreshCheck").val("false");
			}

			$("#node-config-input-mapping").change(function()
			{
				this.mapping = $("#node-config-input-mapping").val();
			});

			$("#node-config-input-mapping").val(this.mapping);



		},

		oneditsave: function ()
		{
		},

		label: function()
		{
			return "LED MATRIX";
		},
	});
</script>

<script type="text/x-red" data-template-name="led-matrix">
	<div class="form-row">
		<label for="node-config-input-width"><i class="icon-bookmark"></i> Width</label>
		<input type="text" id="node-config-input-width">
		<label for="node-config-input-height"><i class="icon-bookmark"></i> Height</label>
		<input type="text" id="node-config-input-height">
	</div>

	<div class="form-row">
		<label for="node-config-input-chained"><i class="icon-bookmark"></i> Chained Panels</label>
		<input type="text" id="node-config-input-chained">
		<label for="node-config-input-parallel"><i class="icon-bookmark"></i> Parallel Panels</label>
		<input type="text" id="node-config-input-parallel">
	</div>

	<div class="form-row">
		<label for="node-config-input-brightness"><i class="icon-bookmark"></i> Panel Brightness</label>
		<input type="text" id="node-config-input-brightness">
	</div>

	<div class="form-row">
		<label for="node-config-input-refreshDelay"> <i class= "icon-bookmark"></i> Refresh Delay milliseconds</label>
		<input type="number" id="node-config-input-refreshDelay" min="0" placeholder="default: 500 milliseconds"/>

		<label for="node-config-refreshCheck"> <i class= "icon-bookmark"></i> Auto Refresh Display</label>
		<select id = "node-config-refreshCheck">
			<option value="true"> auto </option>
			<option value="false"> manual <option>
		</select>

	</div>


<!--
	<div class="form-row">
		<label for="node-config-input-mapping"><i class="icon-bookmark"></i> Hardware Mapping</label>
		<input type="text" id="node-config-input-mapping">
	</div>
-->

	<div class="form-row">
		<label for="node-config-input-mapping"><i class="icon-tag"></i> Hardware Mapping </label>
		<select id= "node-config-input-mapping">
			<option value="adafruit-hat-pwm"> Easybotics</option>
			<option value="regular">Regular</option>
			<option value="adafruit-hat">Adafruit Hat</option>
			<option value="adafruit-hat-pwm">Adafruit Hat Pwm</option>
		</select>
	</div>


<p>
	<b> warning:</b> <br>
	due to quirks with node-red, most of these settings won't apply <br>
	unless you restart node-red (not the browser client),<br>
	or delete this config node and make another one
</p>


</script>

<script type="text/x-red" data-help-name="led-matrix">
	<p>
		<br> <b> height: </b>  height of the led panel
		<br> <b> width: </b>   width of the led panel, use the width of one panel if you are chaining them
		<br> <b> chained panels: </b> amount of panels chained
		<br> <b> parallel:</b> amount of panels wired in parallel
		<br> <b> brightness:</b> brightness as a percentage, 1 - 100
		<br> <b> mapping: </b> type of hardware mapping, what pins hzeller will output too
		<br> <b> autoRefresh: </b> if true flow will try and keep the display updated, otherwise use the refresh node manually
		<br> <b> refresh delay: </b> when autorefresh is turned on, the flow will never update the screen faster than this delay
	</p>
</script>


<!--
	this block describes  the appearance of the node itself
	and also what type of settings it holds
	also the category, config is a special category; all others are arbitrary
-->

<script type="text/javascript">
    RED.nodes.registerType('pixel',{
        category: 'LED Matrix',
        color: '#a6bbcf',
        defaults: {
            name: {value:""},
            color: {value:"haa"},
            matrix: { type:'led-matrix', required:true},
			zLevel: {value: undefined},
        },
        inputs:1,
        outputs:0,
        icon: "pixel-matrix.png",
        label: function() {
            return this.name||"pixel to matrix";
        }
    });
</script>

<!--
	this block describes the settings page where we can select which config nodes to bind
	and other paramters we have previously mentioned in the 'defaults' block up there ^
-->

<script type="text/x-red" data-template-name="pixel">
	<div class='form-row'>
		<label for="node-config-input-matrix"><i class='fa fa-tag'></i> Display</label>
		<input type='text' id='node-input-matrix'/>
	</div>
    <div class="form-row">
        <label for="node-config-input-name"><i class="icon-tag"></i> Name</label>
        <input type="text" id="node-input-name" placeholder="Name">
    </div>
    <div class="form-row">
        <label for="node-config-input-zLevel"><i class="icon-tag"></i> z level</label>
        <input type="number" id="node-input-zLevel" placeholder="-">
    </div>

</script>

<!--
	this block describes the help text
-->

<script type="text/x-red" data-help-name="pixel">
    <p>prints a pixel on the matrix buffer, refresh the matrix to see the result </p>
	<p>Takes an object with properties x, y, r, g, b <b> rgb defines the color </b></p>
	<p>When injected it will add itself to the buffer, and will continue to be printed until a msg.clear property is injected into it

		<br> <b>object example: </b> <br>
		<i>
		msg.payload = { <br>
			&emsp;&emsp;x: 10, <br>
			&emsp;&emsp;y: 10, <br><br>

			&emsp;&emsp;r: 255, <br>
			&emsp;&emsp;g: 0, <br>
			&emsp;&emsp;b: 0, <br>
		}; <br>
		</i>


</p>
</script>

<script type="text/javascript">
	RED.nodes.registerType("refresh-matrix",
	{
		category: 'LED Matrix',
		color: '#a6bbcf',
		defaults:
		{
			name: {value:""},
			matrix: {type: 'led-matrix', required:true},
		},
		inputs:1,
		outputs:0,
		icon: "refresh-matrix.png",
		label: function ()
		{
			return this.name || "refresh-matrix";
		}
	});
</script>

<script type="text/x-red" data-template-name="refresh-matrix">
	<div class="form-row">
		<label for="node-config-input-matrix"><i class='fa fa-tag'></i> Display </label>
		<input type="text" id="node-input-matrix"/>
	</div>

	<div class="form-row">
		<label for="node-config-input-name"> <i class="icon-tag"></i> Name </label>
		<input type="text" id="node-input-name" placeholder="Name">
	</div>
</script>

<script type="text/x-red" data-help-name="refresh-matrix">
	<p> updates the display with vysnc <br><br>
		nodes usually modify a in-memory buffer rather than pushing to the screen frame buffer itself, this node pushes the in memory buffer to the frame buffer when injected

</p>

</script>

<script type="text/javascript">
	RED.nodes.registerType('image-to-matrix',
	{
		category: 'LED Matrix',
		color: '#a6bbcf',

		defaults:
		{
			name: {value:""},
			file: {value:""},
			xOffset: {value:0, required:true},
			yOffset: {value:0, required:true},
			matrix: { type:'led-matrix', required:true},
			zLevel: {value: undefined},
		},

		inputs:1,
		outputs:0,
		icon: "image-matrix.png",
		label: function()
		{
			return this.name || "image to matrix";
		}
	});
</script>


<script type="text/x-red" data-template-name="image-to-matrix">
	<div class='form-row'>
		<label for="node-config-input-matrix"><i class='fa fa-tag'></i> Display</label>
		<input type='text' id='node-input-matrix'/>
	</div>

	<div class="form-row">
		<label for="node-config-input-name"> <i class="icon-tag"></i> Name </label>
		<input type="text" id="node-input-name" placeholder="Name">
	</div>

	<div class="form-row">
		<label for="node-config-input-xOffset"> <i class="fa fa-tag"></i> X position</label>
		<input type="number" id="node-input-xOffset" min="0" placeholder="0"/>
	<div>

	<div class="form-row">
		<label for="node-config-input-yOffset"> <i class="fa fa-tag"></i> Y position</label>
		<input type="number" id="node-input-yOffset" min="0" placeholder="0" />
	<div>
    <div class="form-row">
        <label for="node-config-input-zLevel"><i class="icon-tag"></i> z level</label>
        <input type="number" id="node-input-zLevel" placeholder="-">
    </div>
</script>

<script type="text/x-red" data-help-name="image-to-matrix">
	<p> Takes a url, or a file path  as a payload, and uses the x,y in the settings <br>
		If a gif is injected, the frame displayed will advance on each inject <br><br>

		Also takes an object with the following properties: <br>
		<b>x:</b> x location<br>
		<b>y:</b>y location<br>
		<b>data</b>: the url or file path to a valid image <br>

		<br> <b>object example: </b> <br>
		<i>
		msg.payload = { <br>
			&emsp;&emsp;x: 10, <br>
			&emsp;&emsp;y: 10, <br>
			&emsp;&emsp;data: "https://media.giphy.com/media/UaoxTrl8z1wre/giphy.gif" <br>
		}; <br>
		</i>



		</p>
</script>


<!--
<script type="text/javascript">
	RED.nodes.registerType("clear-matrix",
	{
		category: 'LED Matrix',
		color: '#a6bbcf',
		defaults:
		{
			name: {value:""},
			matrix: {type: "led-matrix",required:true},
		},
		inputs:1,
		outputs:0,
		icon: "clear-matrix.png",
		label: function()
		{
			return this.name || "led-matrix";
		}
	});
</script>

<script type="text/x-red" data-template-name = "clear-matrix">
	<div class="form-row">
		<label for="node-config-input-name"> <i class="icon-tag"></i> Name </label>
		<input type="text" id="node-input-name" placeholder="Name">
	</div>

	<div class="form-row">
		<label for="node-config-input-matrix"><i class='fa fa-tag'></i> Display </label>
		<input type="text" id="node-input-matrix"/>
	</div>
</script>

<script type="text/x-red" data-help-name="clear-matrix">
	<p> clear pixels off the display </p>
</script>

-->

<script type="text/javascript">

		function componentToHex(c)
		{
			var hex = c.toString(16);
			return hex.length == 1 ? "0" + hex : hex;
		}

		function rgbToHex(r, g, b)
		{
			return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
		}


    RED.nodes.registerType('text-to-matrix',{
        category: 'LED Matrix',
        color: '#a6bbcf',

        defaults: {
            name: {value:""},
			xOffset:      {value:0, required: true},
			yOffset:	  {value:0, required: true},
			rgb:		  {value:"0,255,41"},
			font: {value:"fonts/9x18B.bdf", required:true},
			prefix:		  {value:""},
			source:		  {value:"msg.payload"},
			matrix: { type:'led-matrix', required:true},
			zLevel: {value: undefined},
        },

        inputs:1,
        outputs:0,
        icon: "text-matrix.png",
        label: function() {
            return this.name ||"text to matrix";
        },

		oneditprepare: function ()
		{
			const fontDropdown = $("#node-config-input-font");
		//	fontDropdown.append('<option value="_msg_">- set from msg.deviceid -</option>');


			const fonts = ["10x20.bdf", "5x8.bdf",   "6x13B.bdf",  "6x9.bdf",    "7x13O.bdf",  "8x13B.bdf",  "9x15B.bdf",  "9x18.bdf",     "helvR12.bdf",  "tom-thumb.bdf",
"4x6.bdf",    "6x10.bdf",  "6x13.bdf",   "7x13B.bdf",  "7x14B.bdf",  "8x13.bdf",   "9x15.bdf",    "5x7.bdf",    "6x12.bdf",  "6x13O.bdf",  "7x13.bdf",   "7x14.bdf",   "8x13O.bdf",  "9x18B.bdf",  "clR6x12.bdf"]
			fonts.sort();
			for(var i = 0; i < fonts.length; i++)
			{
				const f = fonts[i];
				const text = f;
				const value = f;


				//fontDropdown.append('<option value="_msg_">- set from msg.deviceid -</option>');
				fontDropdown.append('<option value="' + value + '"> ' + text + '</option>');
				console.log('<option value="' + value + '">- ' + text + ' -</option>');


			};





			fontDropdown.change(function()
				{
					this.font = fontDropdown.val();
				});

			fontDropdown.val(this.font);

			$("#node-input-source").change(function()
				{
					this.source = $("#node-input-source").val();
				});


			$("#node-input-source").val(this.source || "msg.payload");


			$("#node-input-rgb2").change(function()
			{
				var hex = $("#node-input-rgb2").val();
				var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
				hex = hex.replace(shorthandRegex, function(m, r, g, b) {
					return r + r + g + g + b + b;
				});

				var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
				var output =  "" + parseInt(result[1], 16) + ',' + parseInt(result[2], 16) + ',' + parseInt(result[3], 16);

				$("#node-input-rgb").val(output);
			});

			var tr = $("#node-input-rgb").val();
			var split = tr.split(',');

			$("#node-input-rgb2").val( rgbToHex( parseInt(split[0]), parseInt(split[1]), parseInt(split[2])));
        },

		oneditsave: function ()
		{
			this.font = $("#node-config-input-font").val();
			//this.font = $("#node-config-input-font").val();

		},

    });
</script>



<script type="text/x-red" data-template-name="text-to-matrix">

	<div class='form-row'>
		<label for="node-config-input-matrix"><i class='fa fa-tag'></i> Display</label>
		<input type='text' id='node-input-matrix'/>
	</div>

    <div class="form-row">
        <label for="node-config-input-name"><i class="icon-tag"></i> Name</label>
        <input type="text" id="node-input-name" placeholder="Name">
    </div>

	<div class='form-row' id="node-config-input-front-row">
		<label for='node-config-input-font'><i class='icon-tag'></i> Font</label>

		<select id="node-config-input-font">
		</select>
	</div>

	<div class="form-row">
		<label for="node-config-input-xOffset"> <i class="fa fa-tag"></i> X position</label>
		<input type="number" id="node-input-xOffset" min="0" placeholder="0"/>
		<label for="node-config-input-yOffset"> <i class="fa fa-tag"></i> Y position</label>
		<input type="number" id="node-input-yOffset" min="0" placeholder="0" />
	</div>


	<div class= "form-row">
		<label for="node-config-input-prefix"> <i class="fa fa-tag"></i> Prefix text</label>
		<input type="text" id="node-input-prefix" />
		<label for="node-config-input-source"> <i class="fa fa-tag"></i> Source</label>
		<input type="text" id="node-input-source" />
	</div>


	<div class = "form-row">
		<label for="node-config-input-rgb"><i class="icon-tag"></i>RGB color </label>
		<input type="text" id="node-input-rgb" placeholder="112,79,86">
		<label for="node-config-input-rgb2"><i class="icon-tag"></i>Color picker</label>
		<input type="color" id="node-input-rgb2" placeholder="#43DB2D">
	</div>

    <div class="form-row">
        <label for="node-config-input-zLevel"><i class="icon-tag"></i> z level</label>
        <input type="number" id="node-input-zLevel" placeholder="-">
    </div>
</script>

<script type="text/x-red" data-help-name="text-to-matrix">
    <p>prints text to the matrix buffer <br>
	If <i> source </i> is a string it uses the x and y coordinates from the settings. <br>
	<i> source </i> can also be an object with the following properties: <br>
	<b> x:</b> X location <br>
	<b> y:</b> Y location <br>
	<b> rgb:</b> rgb color, as a CSV string. Example: "255,0,0" (RED) <br>
	<b> data:</b> text to print <br><br>

	The prefix setting prefixes a string to the output text<br> <br>

	<b> object example: </b> <br>
	<i>
	msg.payload = { <br>
			&emsp;&emsp;x: 10, <br>
			&emsp;&emsp;y: 10, <br>
			&emsp;&emsp;data: "hello world", <br>
			&emsp;&emsp;rgb: "255,0,0" <br>
		}; <br>

	<br<br> <b> warning: source is evalulated with eval() </b>

	</p>

</script>

<script type="text/javascript">
	RED.nodes.registerType('pixel-transform',
	{
		category: 'LED Matrix',
		color: '#a6bbcf',
		defaults:
		{
			name:		{value:""},
			xOffset:	{value:0},
			yOffset:	{value:0},
			refresh:	{value:0},
			rgb:		{value:"0,255,41"},
		},
		inputs: 1,
		outputs: 1,
		icon: "arrow-in.png",
		label: function()
		{
			return this.name || "Data Transform!";
		},


		oneditprepare: function ()
		{

			$("#node-input-rgb2").change(function()
			{
				var hex = $("#node-input-rgb2").val();
				var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
				hex = hex.replace(shorthandRegex, function(m, r, g, b) {
					return r + r + g + g + b + b;
				});

				var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
				var output =  "" + parseInt(result[1], 16) + ',' + parseInt(result[2], 16) + ',' + parseInt(result[3], 16);

				$("#node-input-rgb").val(output);
			});

			var tr = $("#node-input-rgb").val();
			var split = tr.split(',');

			$("#node-input-rgb2").val( rgbToHex( parseInt(split[0]), parseInt(split[1]), parseInt(split[2])));


		},

		oneditsave: function ()
		{
		},




	});
</script>

<script type="text/x-red" data-template-name="pixel-transform">
	<div class = "form-row">
		<label for="node-config-input-name"><i class="icon-tag"></i> Name </label>
		<input type="text" id="node-input-name" placeholder="Name">
	</div>

	<div class = "form-row">
		<label for="node-config-input-xOffset"><i class="icon-tag"></i>X </label>
		<input type="text" id="node-input-xOffset" placeholder="0">
	</div>

	<div class = "form-row">
		<label for="node-config-input-yOffset"><i class="icon-tag"></i>Y </label>
		<input type="text" id="node-input-yOffset" placeholder="0">
	</div>

	<div class = "form-row">
		<label for="node-config-input-rgb"><i class="icon-tag"></i>RGB color </label>
		<input type="text" id="node-input-rgb" placeholder="255,255,255">
	</div>

	<div class = "form-row">
		<label for="node-config-input-rgb2"><i class="icon-tag"></i>Color picker</label>
		<input type="color" id="node-input-rgb2">
	</div>


</script>

<script type="text/x-red" data-help-name="pixel-transform">
	<p>modifies properties of a display object, or spawns one from a string <br> <br>
	   if input is a string will output an object with the following properties: <br><br>
	<b> data: </b> original string input <br>
	<b> x:</b> X location <br>
	<b> y:</b> Y location <br>
	<b> rgb:</b> rgb color, as a CSV string. Example: "255,0,0" (RED) <br><br>

	if input is an object, those properties will be modified



	</p>
</script>

<script type="text/javascript">

	function componentToHex(c)
	{
		var hex = c.toString(16);
		return hex.length == 1 ? "0" + hex : hex;
	}

	function rgbToHex(r, g, b)
	{
		return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
	}


	RED.nodes.registerType('circle-to-matrix',
		{
			category: 'LED Matrix',
			color: '#a6bbcf',

			defaults:
			{
				name:	{value:""},
				xPos:	{value:0, required: true},
				yPos:	{value:0, required: true},
				radius: {value:0, required: true},
				rgb:	{value:"0,255,41"},

				matrix: {type: 'led-matrix', required:true},
				zLevel: {value: undefined},
			},

			inputs: 1,
			outputs:0,
			icon: "circle-matrix.png",
			label: function ()
			{
				return this.name || "circle to matrix";
			},

			oneditprepare: function ()
			{
				$("#node-input-rgb2").change(function()
				{
					var hex = $("#node-input-rgb2").val();
					var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
					hex = hex.replace(shorthandRegex, function(m, r, g, b) {
						return r + r + g + g + b + b;
					});

					var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
					var output =  "" + parseInt(result[1], 16) + ',' + parseInt(result[2], 16) + ',' + parseInt(result[3], 16);

					$("#node-input-rgb").val(output);
				});

				var tr = $("#node-input-rgb").val();
				var split = tr.split(',');

				$("#node-input-rgb2").val( rgbToHex( parseInt(split[0]), parseInt(split[1]), parseInt(split[2])));
			},
		});
</script>

<script type="text/x-red" data-template-name="circle-to-matrix">

	<div class='form-row'>
		<label for="node-config-input-matrix"><i class='fa fa-tag'></i> Display</label>
		<input type='text' id='node-input-matrix'/>
	</div>

	<div class="form-row">
		<label for="node-config-input-name"><i class="icon-tag"></i> Name </label>
		<input type="text" id="node-input-name" placeholder="Name">
	</div>

	<div class="form-row">
		<label for="node-config-input-xPos"> <i class="fa fa-tag"></i> X Position </label>
		<input type="number" id="node-input-xPos" min = "0" placeholder="0" />
	<div>

	<div class="form-row">
		<label for="node-config-input-yPos"> <i class="fa fa-tag"></i> Y Position </label>
		<input type="number" id="node-input-yPos" min = "0" placeholder="0" />
	<div>

	<div class="form-row">
		<label for="node-config-input-radius"> <i class="fa fa-tag"></i> Radius </label>
		<input type="number" id="node-input-radius" min = "0" placeholder="0" />
	<div>


	<div class = "form-row">
		<label for="node-config-input-rgb"><i class="icon-tag"></i>RGB color </label>
		<input type="text" id="node-input-rgb" placeholder="112,79,86">
	</div>

	<div class = "form-row">
		<label for="node-config-input-rgb2"><i class="icon-tag"></i>Color picker</label>
		<input type="color" id="node-input-rgb2" placeholder="#43DB2D">
	</div>
    <div class="form-row">
        <label for="node-config-input-zLevel"><i class="icon-tag"></i> z level</label>
        <input type="number" id="node-input-zLevel" placeholder="-">
    </div>

</script>

<script type="text/x-red" data-help-name="circle-to-matrix">
	<p> Prints a circle to the matrix buffer <br>
		<i> msg.payload </i> can be an object with the following properties: <br>
		<b> x: </b> X location <br>
		<b> y: </b> Y location <br>
		<b> radius: </b> radius <br>
		<b> rgb: </b> an rgb CSV string, example : "255,0,0," (red) <br><br>
		otherwise the settings from the node itself are used </p>
</script>

<script type="text/javascript">

	function componentToHex(c)
	{
		var hex = c.toString(16);
		return hex.length == 1 ? "0" + hex : hex;
	}

	function rgbToHex(r, g, b)
	{
		return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
	}


	RED.nodes.registerType('line-to-matrix',
	{
		category: 'LED Matrix',
		color: '#a6bbcf',

		defaults:
		{
			name:	{value:""},
			x0:	{value:0, required: true},
			y0:  {value:0, required: true},
			x1:  {value:0, required: true},
			y1:  {value:0, required: true},
			rgb:	{value:"0, 255, 41"},

			matrix:	{type: 'led-matrix', required: true},
			zLevel: {value: undefined},
		},

		inputs: 1,
		outputs: 0,
		icon: "line-matrix.png",
		label: function ()
		{
			return this.name || "line to matrix";
		},

		oneditprepare: function ()
		{

				$("#node-input-rgb2").change(function()
				{
					var hex = $("#node-input-rgb2").val();
					var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
					hex = hex.replace(shorthandRegex, function(m, r, g, b) {
						return r + r + g + g + b + b;
					});

					var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
					var output =  "" + parseInt(result[1], 16) + ',' + parseInt(result[2], 16) + ',' + parseInt(result[3], 16);

					$("#node-input-rgb").val(output);
				});

				var tr = $("#node-input-rgb").val();
				var split = tr.split(',');

				$("#node-input-rgb2").val( rgbToHex( parseInt(split[0]), parseInt(split[1]), parseInt(split[2])));

				pixelSelector(2, "linePixelSelect");
		},
	});
</script>


<script type="text/x-red" data-template-name="line-to-matrix">

	<div class='form-row'>
		<label for="node-config-input-matrix"><i class='fa fa-tag'></i> Display</label>
		<input type='text' id='node-input-matrix'/>
	</div>

<!--
	<div class="form-row">
		<label for="node-config-input-name"><i class="icon-tag"></i> Name </label>
		<input type="text" id="node-input-name" placeholder="Name">
	</div>
-->

	<div class="form-row">
		<div class ="col">
			<label for="node-config-input-x0"> <i class="fa fa-tag"></i> X0 Position </label>
			<input type="number" id="node-input-x0" min = "0" placeholder="0" />
		</div>
		<div class ="col">
			<label for="node-config-input-y0"> <i class="fa fa-tag"></i> Y0 Position </label>
			<input type="number" id="node-input-y0" min = "0" placeholder="0" />
		</div>
	<div>

	<div class="form-row">
		<div class="col">
			<label for="node-config-input-x1"> <i class="fa fa-tag"></i> X Position </label>
			<input type="number" id="node-input-x1" min = "0" placeholder="0" />
		<div>
		<div class="col">
			<label for="node-config-input-y1"> <i class="fa fa-tag"></i> Y Position </label>
			<input type="number" id="node-input-y1" min = "0" placeholder="0" />
		<div>
	</div>


	<div class = "form-row">
		<label for="node-config-input-rgb"><i class="icon-tag"></i>RGB color </label>
		<input type="text" id="node-input-rgb" placeholder="112,79,86">
	</div>

	<div class = "form-row">
		<label for="node-config-input-rgb2"><i class="icon-tag"></i>Color picker</label>
		<input type="color" id="node-input-rgb2" placeholder="#43DB2D">
	</div>

	<canvas id="linePixelSelect" style="outline: 1px solid black;" width="512" height="256"></canvas>

    <div class="form-row">
        <label for="node-config-input-zLevel"><i class="icon-tag"></i> z level</label>
        <input type="number" id="node-input-zLevel" placeholder="-">
    </div>

</script>

<script type="text/x-red" data-help-name="line-to-matrix">
	<p> Prints a line to the matrix buffer, refresh the matrix to see the result  <br>
		When injected it will add itself to the buffer, and will continue to be printed until a msg.clear property is injected into it <br>
		Will use the location and color from the settings, or can be injected with an object with the following preoperties: <br><br>
	<b> x0:</b> X location of the start of the line <br>
	<b> y0</b> Y location <br>
	<b> x1:</b> X location of the end of the line <br>
	<b> y1</b> Y location <br>
	<b> rgb:</b> rgb color, as a CSV string. Example: "255,0,0" (RED) <br><br>

	<b> object example: </b> <br>
	<i>
	msg.payload = { <br>
			&emsp;&emsp;x0: 0, <br>
			&emsp;&emsp;y0: 0, <br>
			&emsp;&emsp;x1: 25, <br>
			&emsp;&emsp;y1: 25, <br>
			&emsp;&emsp;rgb: "255,0,0" <br>
		}; <br>

	</p>

</script>




<script type="text/javascript">

	function componentToHex(c)
	{
		var hex = c.toString(16);
		return hex.length == 1 ? "0" + hex : hex;
	}

	function rgbToHex(r, g, b)
	{
		return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
	}


	RED.nodes.registerType('triangle-to-matrix',
	{
		category: 'LED Matrix',
		color: '#a6bbcf',

		defaults:
		{
			name:	{value:""},
			x0:	{value:0, required: true},
			y0:  {value:0, required: true},
			x1:  {value:0, required: true},
			y1:  {value:0, required: true},
			x2:  {value:0, required: true},
			y2:  {value:0, required: true},
			rgb:	{value:"0, 255, 41"},

			matrix:	{type: 'led-matrix', required: true},
			zLevel: {value: undefined},
		},

		inputs: 1,
		outputs: 0,
		icon: "triangle-matrix.png",
		label: function ()
		{
			return this.name || "triangle to matrix";
		},

		oneditprepare: function ()
		{

				$("#node-input-rgb2").change(function()
				{
					var hex = $("#node-input-rgb2").val();
					var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
					hex = hex.replace(shorthandRegex, function(m, r, g, b) {
						return r + r + g + g + b + b;
					});

					var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
					var output =  "" + parseInt(result[1], 16) + ',' + parseInt(result[2], 16) + ',' + parseInt(result[3], 16);

					$("#node-input-rgb").val(output);
				});

				var tr = $("#node-input-rgb").val();
				var split = tr.split(',');

				$("#node-input-rgb2").val( rgbToHex( parseInt(split[0]), parseInt(split[1]), parseInt(split[2])));

				//pixelReDraw(3, "trianglePixelSelect");
				pixelSelector(3, "trianglePixelSelect");
		},

		oneditsave: function ()
		{
		},

	});
</script>


<script type="text/x-red" data-template-name="triangle-to-matrix">

	<div class='form-row'>
		<label for="node-config-input-matrix"><i class='fa fa-tag'></i> Display</label>
		<input type='text' id='node-input-matrix'/>
	</div>

	<div class="form-row">
		<label for="node-config-input-name"><i class="icon-tag"></i> Name </label>
		<input type="text" id="node-input-name" placeholder="Name">
	</div>

	<div class="form-row">
		<label for="node-config-input-x0"> <i class="fa fa-tag"></i> Point 1: X Position </label>
		<input type="number" id="node-input-x0" min = "0" placeholder="0" />
	<div>

	<div class="form-row">
		<label for="node-config-input-y0"> <i class="fa fa-tag"></i> Point 1: Y Position </label>
		<input type="number" id="node-input-y0" min = "0" placeholder="0" />
	<div>

	<div class="form-row">
		<label for="node-config-input-x1"> <i class="fa fa-tag"></i> Point 2: X Position </label>
		<input type="number" id="node-input-x1" min = "0" placeholder="0" />
	<div>

	<div class="form-row">
		<label for="node-config-input-y1"> <i class="fa fa-tag"></i> Point 2: Y Position </label>
		<input type="number" id="node-input-y1" min = "0" placeholder="0" />
	<div>

	<div class="form-row">
		<label for="node-config-input-x2"> <i class="fa fa-tag"></i> Point 3: X Position </label>
		<input type="number" id="node-input-x2" min = "0" placeholder="0" />
	<div>

	<div class="form-row">
		<label for="node-config-input-y2"> <i class="fa fa-tag"></i> Point 3: Y Position </label>
		<input type="number" id="node-input-y2" min = "0" placeholder="0" />
	<div>

	<div class = "form-row">
		<label for="node-config-input-rgb"><i class="icon-tag"></i>RGB color </label>
		<input type="text" id="node-input-rgb" placeholder="112,79,86">
	</div>

	<div class = "form-row">
		<label for="node-config-input-rgb2"><i class="icon-tag"></i>Color picker</label>
		<input type="color" id="node-input-rgb2" placeholder="#43DB2D">
	</div>

	<canvas id="trianglePixelSelect" style="outline: 1px solid black;" width="512" height="256"></canvas>

    <div class="form-row">
        <label for="node-config-input-zLevel"><i class="icon-tag"></i> z level</label>
        <input type="number" id="node-input-zLevel" placeholder="-">
    </div>
</script>

<script type="text/x-red" data-help-name="triangle-to-matrix">
	<p> Prints a triangle to the matrix buffer, refresh the matrix to see the result  <br>
		When injected it will add itself to the buffer, and will continue to be printed until a msg.clear property is injected into it <br>
		Will use the location and color from the settings, or can be injected with an object with the following preoperties: <br><br>
	<b> x0:</b> X location of the first point <br>
	<b> y0:</b> Y location <br>
	<b> x1:</b> X location of the second point <br>
	<b> y1:</b> Y location <br>
	<b> x2:</b> X location of the third point <br>
	<b> y2:</b> Y location <br>
	<b> rgb:</b> rgb color, as a CSV string. Example: "255,0,0" (RED) <br><br>

	<b> object example: </b> <br>
	<i>
	msg.payload = { <br>
			&emsp;&emsp;x0: 0, <br>
			&emsp;&emsp;y0: 0, <br>
			&emsp;&emsp;x1: 25, <br>
			&emsp;&emsp;y1: 25, <br>
			&emsp;&emsp;x2: 10, <br>
			&emsp;&emsp;y2: 10, <br>
			&emsp;&emsp;rgb: "255,0,0" <br>
		}; <br>

	</p>
</script>

<script type="text/javascript">
	RED.nodes.registerType("clear-node",
	{
		category: 'LED Matrix',
		color: '#a6bbcf',
		inputs:  1,
		outputs: 1,
		icon: "refresh-matrix.png",
		label: function ()
		{
			return "clear node";
		}

	});
</script>

<script type="text/x-red" data-help-name="clear-node">
	<p> Clears a shape, text, or image node from the display <br>
		Note that these nodes usually re-impose themselves when injected, so if you are injecting on a loop it might just reappear on the display after you clear it </p>
</script>

<script type="text/javascript">

	function componentToHex(c)
	{
		var hex = c.toString(16);
		return hex.length == 1 ? "0" + hex : hex;
	}

	function rgbToHex(r, g, b)
	{
		return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
	}


	RED.nodes.registerType('realtime-circle-to-matrix',
		{
			category: 'LED Matrix',
			color: '#F4ED57',

			defaults:
			{
				name:	{value:""},
				xPos:	{value:0, required: true},
				yPos:	{value:0, required: true},
				radius: {value:0, required: true},
				rgb:	{value:"0,255,41"},

				matrix: {type: 'led-matrix', required:true},
			},

			inputs: 1,
			outputs:0,
			icon: "circle-matrix.png",
			label: function ()
			{
				return this.name || "realtime circle";
			},

			oneditprepare: function ()
			{
				$("#node-input-rgb2").change(function()
				{
					var hex = $("#node-input-rgb2").val();
					var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
					hex = hex.replace(shorthandRegex, function(m, r, g, b) {
						return r + r + g + g + b + b;
					});

					var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
					var output =  "" + parseInt(result[1], 16) + ',' + parseInt(result[2], 16) + ',' + parseInt(result[3], 16);

					$("#node-input-rgb").val(output);
				});

				var tr = $("#node-input-rgb").val();
				var split = tr.split(',');

				$("#node-input-rgb2").val( rgbToHex( parseInt(split[0]), parseInt(split[1]), parseInt(split[2])));
			},
		});
</script>

<script type="text/x-red" data-template-name="realtime-circle-to-matrix">

	<div class='form-row'>
		<label for="node-config-input-matrix"><i class='fa fa-tag'></i> Display</label>
		<input type='text' id='node-input-matrix'/>
	</div>


	<div class="form-row">
		<label for="node-config-input-name"><i class="icon-tag"></i> Name </label>
		<input type="text" id="node-input-name" placeholder="Name">
	</div>

	<div class="form-row">
		<label for="node-config-input-x"> <i class="fa fa-tag"></i> X Position </label>
		<input type="number" id="node-input-xPos" min = "0" placeholder="0" />
	<div>

	<div class="form-row">
		<label for="node-config-input-y"> <i class="fa fa-tag"></i> Y Position </label>
		<input type="number" id="node-input-yPos" min = "0" placeholder="0" />
	<div>

	<div class="form-row">
		<label for="node-config-input-radius"> <i class="fa fa-tag"></i> Radius </label>
		<input type="number" id="node-input-radius" min = "0" placeholder="0" />
	<div>


	<div class = "form-row">
		<label for="node-config-input-rgb"><i class="icon-tag"></i>RGB color </label>
		<input type="text" id="node-input-rgb" placeholder="112,79,86">
	</div>

	<div class = "form-row">
		<label for="node-config-input-rgb2"><i class="icon-tag"></i>Color picker</label>
		<input type="color" id="node-input-rgb2" placeholder="#43DB2D">
	</div>

</script>

<script type="text/x-red" data-help-name="circle-to-matrix">
	<p> Prints a circle to the matrix buffer <br>
		<i> msg.payload </i> can be an object with the following properties: <br>
		<b> x: </b> X location <br>
		<b> y: </b> Y location <br>
		<b> radius: </b> radius <br>
		<b> rgb: </b> an rgb CSV string, example : "255,0,0," (red) <br><br>
		otherwise the settings from the node itself are used </p>
</script>

<script type="text/javascript">

	function componentToHex(c)
	{
		var hex = c.toString(16);
		return hex.length == 1 ? "0" + hex : hex;
	}

	function rgbToHex(r, g, b)
	{
		return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
	}

	RED.nodes.registerType('canvas-to-matrix',
	{
		category: 'LED Matrix',
		color: '#a6bbcf',

		defaults:
		{
			name:		{value:""},
			rgb:		{value: "255,255,255"},
			matrix:		{type: 'led-matrix', required: true},
			zLevel:		{value: undefined},
			imageUrl:	{value: undefined},
		},

		inputs: 1,
		outputs: 0,
		icon: "image-matrix.png",
		label: function ()
		{
			return this.name || "canvas to matrix";
		},

		oneditprepare: function ()
		{
			$("#node-input-rgb2").change(function()
			{
				var hex = $("#node-input-rgb2").val();
				var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
				hex = hex.replace(shorthandRegex, function(m, r, g, b) {
					return r + r + g + g + b + b;
				});

				var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
				var output =  "" + parseInt(result[1], 16) + ',' + parseInt(result[2], 16) + ',' + parseInt(result[3], 16);

				$("#node-input-rgb").val(output);
			});

			var tr = $("#node-input-rgb").val();
			var split = tr.split(',');

			$("#node-input-rgb2").val( rgbToHex( parseInt(split[0]), parseInt(split[1]), parseInt(split[2])));

			pixelSelector(3, "canvasPixelSelect", true, false, "outputCanvas", "node-input-rgb2");
		},

		oneditsave: function ()
		{
			const canvas = document.getElementById("outputCanvas");
			const context = canvas.getContext('2d');

			const img    = canvas.toDataURL("image/png");

			this.imageUrl =	img;
		},
	});
</script>

<script type="text/x-red" data-template-name="canvas-to-matrix">

	<div class='form-row'>
		<label for="node-config-input-matrix"><i class='fa fa-tag'></i> Display</label>
		<input type='text' id='node-input-matrix'/>
	</div>

	<div class="form-row">
		<label for="node-config-input-name"><i class="icon-tag"></i> Name </label>
		<input type="text" id="node-input-name" placeholder="Name">
	</div>

	<div class = "form-row">
		<label for="node-config-input-rgb"><i class="icon-tag"></i>RGB color </label>
		<input type="text" id="node-input-rgb" placeholder="255,255,255">
	</div>

	<div class = "form-row">
		<label for="node-config-input-rgb2"><i class="icon-tag"></i>Color picker</label>
		<input type="color" id="node-input-rgb2">
	</div>

	<canvas id="canvasPixelSelect" style="outline: 1px solid black;" width="512" height="256"></canvas>
	<canvas id="outputCanvas" style="outline: 1px solid black;" width="128" height="64"></canvas>

    <div class="form-row">
        <label for="node-config-input-zLevel"><i class="icon-tag"></i> z level</label>
        <input type="number" id="node-input-zLevel" placeholder="-">
    </div>
</script>
